<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Drink Slosh (iOS Test)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0f14; color:#e8eef6; font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif; }
    .wrap { height:100%; display:flex; flex-direction:column; }
    .topbar { padding:14px 14px 10px; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .title { font-size:16px; opacity:0.95; }
    .hint { font-size:12px; opacity:0.7; line-height:1.25; }
    .btn {
      appearance:none; border:0; border-radius:14px; padding:12px 16px;
      background:#2b6cff; color:white; font-weight:700; font-size:16px;
      box-shadow: 0 8px 24px rgba(43,108,255,0.35);
      cursor:pointer;
    }
    .btn:active { transform: translateY(1px); }
    .stage { flex:1; display:flex; align-items:center; justify-content:center; padding: 10px 12px 18px; }
    canvas { width: 100%; max-width: 520px; height: auto; border-radius: 22px; background: radial-gradient(1200px 700px at 50% 20%, rgba(255,255,255,0.05), rgba(255,255,255,0.0) 45%); }
    .footer { padding: 0 14px 14px; font-size: 12px; opacity:0.7; }
    .pill { display:inline-block; padding:4px 8px; border-radius: 999px; background: rgba(255,255,255,0.08); margin-right:6px; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div>
      <div class="title">Drink Slosh (iOS Test)</div>
      <div class="hint">Play → 모션 권한. 폰을 화면 수직축으로 회전하면 표면이 반대로 회전해(지면 수평 유지). 넘치면 실제로 줄어듭니다.</div>
    </div>
    <button id="playBtn" class="btn">Play</button>
  </div>

  <div class="stage">
    <canvas id="c" width="900" height="1200"></canvas>
  </div>

  <div class="footer">
    <span class="pill">yaw(각도): 표면 각도</span>
    <span class="pill">중력(기울기): 토핑 이동</span>
    <span class="pill">넘침: 레벨 감소</span>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;

  const cup = { x: cx, y: cy + 40, topW: 420, botW: 300, h: 620, rim: 26, wall: 18 };

  const drink = {
    color: { r: 207, g: 126, b: 111 },
    level: 0.78,
    targetLevel: 0.78
  };

  const toppings = [];
  const TOPPING_COUNT = 38;

  // ---------- utils ----------
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rgba(c,a){ return `rgba(${c.r},${c.g},${c.b},${a})`; }
  function wrapRad(x){
    x = (x + Math.PI) % (Math.PI*2);
    if (x < 0) x += Math.PI*2;
    return x - Math.PI;
  }
  function degToRad(d){ return d * Math.PI / 180; }

  function resetToppings(){
    toppings.length = 0;
    for (let i=0;i<TOPPING_COUNT;i++){
      toppings.push({
        x: cup.x + (Math.random()-0.5) * (cup.topW*0.35),
        y: cup.y + (Math.random()*0.45 + 0.1) * cup.h,
        r: 10 + Math.random()*6,
        vx: (Math.random()-0.5)*2,
        vy: (Math.random()-0.5)*1.5,
        kind: Math.random() < 0.75 ? "boba" : "jelly"
      });
    }
  }
  resetToppings();

  // ---------- sensors ----------
  // Gravity tilt (for toppings)
  let tiltLR = 0; // -1..1
  let tiltFB = 0; // -1..1
  let hasMotion = false;

  // Yaw angle (for surface): DeviceOrientation alpha with baseline offset
  let yaw0 = null;
  let yawRad = 0;

  // Surface theta (smoothed)
  let surfaceTheta = 0;
  let surfaceThetaVel = 0;
  const thetaStiff = 18.0;
  const thetaDamp  = 0.82;

  // wave
  let wavePhase = 0;
  let waveAmp = 0;

  // overflow
  let overflowX = null;
  let overflowAmt = 0;
  let overflowHold = 0;
  
  // 디버그 표시용(매 프레임 update에서 계산한 값 저장)
  let dbg_rimY = 0;
  let dbg_mouthW = 0;
  let dbg_overflowHold = 0;



  function handleMotion(e){
    const g = e.accelerationIncludingGravity;
    if (!g) return;

    const gx = (typeof g.x === "number") ? g.x : 0;
    const gy = (typeof g.y === "number") ? g.y : 0;

    tiltLR = clamp((-gx)/9.81, -1, 1);
    tiltFB = clamp((gy)/9.81, -1, 1);
    hasMotion = true;
  }

  function handleOrientation(e){
    if (typeof e.alpha !== "number") return;
    const a = degToRad(e.alpha);

    if (yaw0 === null) yaw0 = a;  // baseline after Play
    yawRad = wrapRad(a - yaw0);
  }

  // ---------- audio (optional beep) ----------
  let audioCtx = null;
  function beepSip(intensity){
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filt = audioCtx.createBiquadFilter();
    filt.type = "lowpass";
    filt.frequency.setValueAtTime(900 + 700*intensity, t0);

    osc.type = "triangle";
    osc.frequency.setValueAtTime(260 + 120*intensity, t0);

    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(0.08 + 0.06*intensity, t0 + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.18);

    osc.connect(filt).connect(gain).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + 0.2);
  }

  // ---------- cup geometry helpers ----------
  function cupWidthAt(y){
    const t = clamp(y / cup.h, 0, 1);
    return cup.topW + (cup.botW - cup.topW) * t;
  }
  function cupXBoundsAt(yAbs){
    const y = yAbs - (cup.y - cup.h/2);
    const w = cupWidthAt(y);
    return { left: cup.x - w/2, right: cup.x + w/2 };
  }
  function insideCup(x, y){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;
    if (y < topY || y > botY) return false;
    const b = cupXBoundsAt(y);
    const margin = cup.wall*0.55;
    return (x > b.left + margin && x < b.right - margin);
  }

  // ---------- drawing ----------
  function drawCup(){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;

    ctx.save();
    ctx.lineWidth = cup.wall;
    ctx.strokeStyle = "rgba(240,248,255,0.85)";
    ctx.fillStyle = "rgba(255,255,255,0.06)";

    ctx.beginPath();
    ctx.moveTo(cup.x - cup.topW/2, topY);
    ctx.lineTo(cup.x - cup.botW/2, botY);
    ctx.quadraticCurveTo(cup.x, botY + 30, cup.x + cup.botW/2, botY);
    ctx.lineTo(cup.x + cup.topW/2, topY);
    ctx.quadraticCurveTo(cup.x, topY - 20, cup.x - cup.topW/2, topY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.5)";
    ctx.beginPath();
    ctx.ellipse(cup.x, topY, cup.topW*0.52, cup.rim, 0, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
  }

  function drawLiquid(){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;
    const liquidTop = botY - cup.h * drink.level;

    ctx.save();

    // clip to inside cup
    ctx.beginPath();
    ctx.moveTo(cup.x - cup.topW/2 + cup.wall, topY + cup.wall);
    ctx.lineTo(cup.x - cup.botW/2 + cup.wall, botY - cup.wall);
    ctx.quadraticCurveTo(cup.x, botY + 20, cup.x + cup.botW/2 - cup.wall, botY - cup.wall);
    ctx.lineTo(cup.x + cup.topW/2 - cup.wall, topY + cup.wall);
    ctx.quadraticCurveTo(cup.x, topY - 10, cup.x - cup.topW/2 + cup.wall, topY + cup.wall);
    ctx.closePath();
    ctx.clip();

    ctx.fillStyle = rgba(drink.color, 0.92);

    const theta = surfaceTheta;
    const dx = Math.cos(theta), dy = Math.sin(theta);
    const nx = -dy, ny = dx;

    const amp = 12 + 22 * waveAmp;
    const midX = cup.x;
    const midY = liquidTop;

    const span = Math.max(cup.topW, cup.h) * 0.9;
    const N = 44;

    ctx.beginPath();
    for (let i=0;i<=N;i++){
      const t = i / N;
      const s = (t - 0.5) * 2 * span;

      let x = midX + dx * s;
      let y = midY + dy * s;

      const w = Math.sin(wavePhase + t*2.6) * amp;
      x += nx * w;
      y += ny * w;

      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }

    ctx.lineTo(W + 1000, botY + 3000);
    ctx.lineTo(-1000, botY + 3000);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 6;
    ctx.beginPath();
    for (let i=0;i<=N;i++){
      const t = i / N;
      const s = (t - 0.5) * 2 * span;

      let x = midX + dx * s;
      let y = midY + dy * s;

      const w = Math.sin(wavePhase + t*2.6) * amp;
      x += nx * w;
      y += ny * w;

      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    const grad = ctx.createLinearGradient(cup.x - 200, topY, cup.x + 220, botY);
    grad.addColorStop(0, "rgba(255,255,255,0.10)");
    grad.addColorStop(0.5, "rgba(255,255,255,0.00)");
    grad.addColorStop(1, "rgba(255,255,255,0.08)");
    ctx.fillStyle = grad;
    ctx.fillRect(0, topY, W, cup.h);

    ctx.restore();
  }

  // roundRect polyfill
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+rr, y);
      this.arcTo(x+w, y, x+w, y+h, rr);
      this.arcTo(x+w, y+h, x, y+h, rr);
      this.arcTo(x, y+h, x, y, rr);
      this.arcTo(x, y, x+w, y, rr);
      this.closePath();
      return this;
    }
  }

  function drawToppings(){
    const botY = cup.y + cup.h/2;
    const liquidTop = botY - cup.h * drink.level;
    const sorted = [...toppings].sort((a,b)=> (a.kind==="jelly") - (b.kind==="jelly"));

    for (const p of sorted){
      if (!insideCup(p.x, p.y)) continue;
      if (p.y < liquidTop - 40) continue;

      if (p.kind === "boba"){
        ctx.fillStyle = "rgba(35,20,18,0.95)";
        ctx.beginPath();
        ctx.ellipse(p.x, p.y, p.r, p.r*0.95, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.20)";
        ctx.beginPath();
        ctx.ellipse(p.x - p.r*0.25, p.y - p.r*0.25, p.r*0.35, p.r*0.25, -0.5, 0, Math.PI*2);
        ctx.fill();
      } else {
        ctx.fillStyle = "rgba(255,210,120,0.55)";
        ctx.beginPath();
        ctx.roundRect(p.x - p.r, p.y - p.r*0.75, p.r*2, p.r*1.5, 6);
        ctx.fill();
      }
    }
  }

  // ---------- update ----------
  function update(dt){
    // shared vertical bounds
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;

    // 1) surface angle target: (당신이 방향 맞춘 값)
    const targetTheta = +yawRad;
    const err = wrapRad(targetTheta - surfaceTheta);

    surfaceThetaVel += err * thetaStiff * dt;
    surfaceThetaVel *= Math.pow(thetaDamp, dt*60);
    surfaceTheta += surfaceThetaVel * dt;
    surfaceTheta = wrapRad(surfaceTheta);

    wavePhase += 2.0 * dt;
    waveAmp = clamp(waveAmp * 0.92 + Math.min(1, Math.abs(surfaceThetaVel) * 0.8), 0, 1);

    // 2) overflow detection + drain (mouth open)
    // --- 핵심: "입구(상단) 근처의 x구간"에서만 넘침을 판정 ---
    const rimY = topY + cup.wall * 0.35;     // ✅ 더 위로(덜 민감). 0.2~0.6 튜닝
    const mouthW = cup.topW * 0.46;          // ✅ 입구 안쪽 폭만 사용(0.40~0.52 튜닝)
    
    const theta = surfaceTheta;
    const dx = Math.cos(theta), dy = Math.sin(theta);
    const nx = -dy, ny = dx;
    
    const midX = cup.x;
    const midY = botY - cup.h * drink.level;
    
    const amp = 12 + 22 * waveAmp;
    dbg_rimY = rimY;
    dbg_mouthW = mouthW;

    
    
    // "입구 구간"에서만 샘플링: x가 아니라, 표면선의 파라미터 s를 사용하되,
    // 중앙 근처만 보도록 span을 mouthW 기준으로 제한
    const span = mouthW;         // ✅ 기존처럼 컵 전체 span 쓰지 않음
    const N = 28;
    
    let overSum = 0;
    let overMinY = Infinity;
    let overX = null;
    
    for (let i=0;i<=N;i++){
      const t = i / N;
      const s = (t - 0.5) * 2 * span;
    
      const w = Math.sin(wavePhase + t*2.6) * amp;
    
      const x = midX + dx*s + nx*w;
      const y = midY + dy*s + ny*w;
    
      // "입구 근처" 조건을 한번 더 걸어서 안전장치
      if (Math.abs(x - cup.x) > mouthW) continue;
    
      if (y < rimY) {
        const d = (rimY - y);
        overSum += d;
        if (y < overMinY) { overMinY = y; overX = x; }
      }
    }
    
    overflowAmt = overSum / (N+1);
    overflowX = overX;
    
    // --- 지속 필터: 잠깐 스파이크로는 안 줄어들게 ---
    const on = (overflowAmt > 0.7); // ✅ 넘침으로 인정하는 최소 강도(0.8~2.0 튜닝)
    overflowHold += (on ? 1 : -1) * dt * 3.0; // 반응 속도
    overflowHold = clamp(overflowHold, 0, 1);
    
    // --- 실제 drain: hold가 어느 정도 쌓인 뒤에만 ---
    if (overflowHold > 0.35 && drink.level > 0.06) {
      const k = 0.002; // ✅ 기존보다 약간 낮게 시작(0.00035~0.0012)
      drink.targetLevel = Math.max(0.05, drink.targetLevel - overflowAmt * k);
    }
    dbg_overflowHold = overflowHold;


    // 3) level smoothing
    drink.level += (drink.targetLevel - drink.level) * (1 - Math.pow(0.0008, dt));

    // 4) toppings physics (gravity tilt only)
    const gX = -tiltLR * 0.55; // 방향 반대로 느껴지면 +로 바꾸기
    const gY = 0.22;

    const liquidTop = botY - cup.h * drink.level;

    for (const p of toppings){
      p.vx += gX;
      p.vy += gY;

      p.vx *= 0.96;
      p.vy *= 0.96;

      p.x += p.vx;
      p.y += p.vy;

      // floor collision
      if (p.y > botY - cup.wall*0.8 - p.r){
        p.y = botY - cup.wall*0.8 - p.r;
        p.vy *= -0.35;
        p.vx *= 0.85;
      }

      // extra floor friction (after floor collision)
      const onFloor = (p.y >= (botY - cup.wall*0.8 - p.r - 0.5));
      if (onFloor) {
        p.vx *= 0.88; // 0.85~0.93
      }

      // top clamp
      if (p.y < topY + cup.wall*1.4 + p.r){
        p.y = topY + cup.wall*1.4 + p.r;
        p.vy *= -0.20;
      }

      // side walls
      const bounds = cupXBoundsAt(p.y);
      const left = bounds.left + cup.wall*1.0 + p.r;
      const right = bounds.right - cup.wall*1.0 - p.r;

      if (p.x < left){ p.x = left; p.vx *= -0.35; }
      if (p.x > right){ p.x = right; p.vx *= -0.35; }

      // buoyancy-ish
      if (p.y < liquidTop + 30){
        p.vy += 0.6;
      }
    }
  }
  function drawDebugOverlay(){
  const topY = cup.y - cup.h/2;

  ctx.save();

  // 1) rimY(넘침 기준선) 표시
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(cup.x - cup.topW*0.55, dbg_rimY);
  ctx.lineTo(cup.x + cup.topW*0.55, dbg_rimY);
  ctx.stroke();

  // 2) mouthW(판정 폭) 표시: 입구 중앙 기준 좌/우 경계선
  ctx.strokeStyle = "rgba(0,255,255,0.22)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(cup.x - dbg_mouthW, topY - 40);
  ctx.lineTo(cup.x - dbg_mouthW, topY + 80);
  ctx.moveTo(cup.x + dbg_mouthW, topY - 40);
  ctx.lineTo(cup.x + dbg_mouthW, topY + 80);
  ctx.stroke();

  // 3) overflowX(가장 많이 넘친 점) 표시
  if (overflowX !== null){
    ctx.fillStyle = "rgba(255,80,80,0.8)";
    ctx.beginPath();
    ctx.arc(overflowX, dbg_rimY, 8, 0, Math.PI*2);
    ctx.fill();
  }

  // 4) 텍스트 상태
  ctx.fillStyle = "rgba(255,255,255,0.65)";
  ctx.font = "18px -apple-system, system-ui, Segoe UI, Roboto, sans-serif";
  ctx.fillText(`overflowAmt: ${overflowAmt.toFixed(2)} | hold: ${dbg_overflowHold.toFixed(2)}`, 40, 132);

  ctx.restore();
}

  function render(){
    ctx.clearRect(0,0,W,H);

    ctx.save();
    const bg = ctx.createRadialGradient(cx, cy-200, 40, cx, cy, 820);
    bg.addColorStop(0, "rgba(80,120,255,0.10)");
    bg.addColorStop(0.5, "rgba(255,160,120,0.06)");
    bg.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    drawLiquid();
    drawToppings();
    drawCup();
    drawDebugOverlay();


    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = "24px -apple-system, system-ui, Segoe UI, Roboto, sans-serif";
    ctx.fillText(hasMotion ? "기울여 보세요 (토핑 이동 / 넘침=레벨 감소)" : "Play 후 모션 허용 필요", 40, 64);

    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.font = "20px -apple-system, system-ui, Segoe UI, Roboto, sans-serif";
    ctx.fillText(`레벨: ${Math.round(drink.level*100)}% | yaw: ${Math.round(yawRad*180/Math.PI)}° | surface: ${Math.round(surfaceTheta*180/Math.PI)}° | overflow: ${overflowAmt.toFixed(1)}`, 40, 96);
    ctx.restore();
  }

  // ---------- raf ----------
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // ---------- permission / start ----------
  async function requestMotion(){
    const DOE = window.DeviceOrientationEvent;
    const DME = window.DeviceMotionEvent;

    const fn = (DOE && typeof DOE.requestPermission === "function") ? DOE.requestPermission
           : (DME && typeof DME.requestPermission === "function") ? DME.requestPermission
           : null;

    if (!fn) return true;
    const res = await fn.call(DOE || DME);
    return res === "granted";
  }

  async function start(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      try { await audioCtx.resume(); } catch(e){}
    }

    try{
      const ok = await requestMotion();
      if (!ok) alert("모션 권한이 거부되어 일부 동작이 제한됩니다.");
    } catch(e){}

    window.addEventListener("devicemotion", handleMotion, true);
    window.addEventListener("deviceorientation", handleOrientation, true);

    yaw0 = null;
    yawRad = 0;
    surfaceTheta = 0;
    surfaceThetaVel = 0;

    drink.level = 0.78;
    drink.targetLevel = 0.78;

    waveAmp = 0;
    overflowAmt = 0;
    overflowX = null;

    resetToppings();
    hasMotion = false;

    if (!start._started){
      start._started = true;
      requestAnimationFrame(loop);
    }

    beepSip(0.2);
  }

  document.getElementById("playBtn").addEventListener("click", start);
})();
</script>
</body>
</html>



