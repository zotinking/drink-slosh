<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Drink Slosh (iOS Test)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0f14; color:#e8eef6; font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif; }
    .wrap { height:100%; display:flex; flex-direction:column; }
    .topbar {
      padding:14px 14px 10px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .title { font-size:16px; opacity:0.95; }
    .hint { font-size:12px; opacity:0.7; line-height:1.25; }
    .btn {
      appearance:none; border:0; border-radius:14px; padding:12px 16px;
      background:#2b6cff; color:white; font-weight:700; font-size:16px;
      box-shadow: 0 8px 24px rgba(43,108,255,0.35);
      cursor:pointer;
    }
    .btn:active { transform: translateY(1px); }
    .stage { flex:1; display:flex; align-items:center; justify-content:center; padding: 10px 12px 18px; }
    canvas { width: 100%; max-width: 520px; height: auto; border-radius: 22px; background: radial-gradient(1200px 700px at 50% 20%, rgba(255,255,255,0.05), rgba(255,255,255,0.0) 45%); }
    .footer { padding: 0 14px 14px; font-size: 12px; opacity:0.7; }
    .pill {
      display:inline-block; padding:4px 8px; border-radius: 999px;
      background: rgba(255,255,255,0.08); margin-right:6px;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div>
      <div class="title">Drink Slosh (iOS Test)</div>
      <div class="hint">Play를 누르면 모션 권한을 요청하고, 실제로 기울이면 출렁이며 마실 수 있어요. (yaw 회전에는 거의 반응하지 않음)</div>
    </div>
    <button id="playBtn" class="btn">Play</button>
  </div>

  <div class="stage">
    <canvas id="c" width="900" height="1200"></canvas>
  </div>

  <div class="footer">
    <span class="pill">좌/우·앞/뒤 기울이기: 슬로싱</span>
    <span class="pill">앞으로 많이 기울이기: 마시기</span>
    <span class="pill">Play는 권한/오디오 트리거</span>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // ---- Scene params ----
  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;

  // Cup geometry
  const cup = {
    x: cx, y: cy + 40,
    topW: 420, botW: 300, h: 620,
    rim: 26, wall: 18
  };

  // Drink preset (auto-filled)
  const drink = {
    color: { r: 207, g: 126, b: 111 }, // milk-tea-ish
    level: 0.78,       // current 0..1
    targetLevel: 0.78  // target 0..1
  };

  // Topping particles
  const toppings = [];
  const TOPPING_COUNT = 38;

  function resetToppings() {
    toppings.length = 0;
    for (let i=0;i<TOPPING_COUNT;i++){
      toppings.push({
        x: cup.x + (Math.random()-0.5) * (cup.topW*0.35),
        y: cup.y + (Math.random()*0.45 + 0.1) * cup.h,
        r: 10 + Math.random()*6,
        vx: (Math.random()-0.5)*2,
        vy: (Math.random()-0.5)*1.5,
        kind: Math.random() < 0.75 ? "boba" : "jelly"
      });
    }
  }
  resetToppings();

  // ---- Motion input (gravity-based: devicemotion) ----
  let tiltLR = 0;   // left-right  (-1..1)
  let tiltFB = 0;   // front-back  (-1..1)
  let hasMotion = false;

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  // Use accelerationIncludingGravity so yaw(z-axis) rotation does NOT change tilt much.
  function handleMotion(e){
    const g = e.accelerationIncludingGravity;
    if (!g) return;

    const gx = (typeof g.x === "number") ? g.x : 0;
    const gy = (typeof g.y === "number") ? g.y : 0;

    // NOTE:
    // - These signs are chosen to feel intuitive in portrait.
    // - If 좌/우가 반대로 느껴지면 tiltLR 부호만 바꾸면 됩니다.
    tiltLR = clamp((-gx) / 9.81, -1, 1);
    tiltFB = clamp((gy) / 9.81, -1, 1);

    hasMotion = true;
  }

  // ---- Slosh model (spring + damping) ----
  let surfaceAngle = 0;   // small scalar representing slope
  let surfaceVel   = 0;
  const stiffness = 0.09;
  const damping   = 0.88;

  // Secondary wave
  let wavePhase = 0;
  let waveAmp = 0;

  // ---- "Sip" effect ----
  let sipping = false;
  let sipStrength = 0; // 0..1
  let sipCooldown = 0;

  // ---- Audio (simple synthesized "sip") ----
  let audioCtx = null;

  function beepSip(intensity){
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filt = audioCtx.createBiquadFilter();
    filt.type = "lowpass";
    filt.frequency.setValueAtTime(900 + 700*intensity, t0);

    osc.type = "triangle";
    osc.frequency.setValueAtTime(260 + 120*intensity, t0);

    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(0.10 + 0.08*intensity, t0 + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);

    osc.connect(filt).connect(gain).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + 0.25);
  }

  // ---- Utilities: cup shape ----
  function cupWidthAt(y){
    // y: 0..cup.h from top to bottom
    const t = clamp(y / cup.h, 0, 1);
    return cup.topW + (cup.botW - cup.topW) * t;
  }

  function cupXBoundsAt(yAbs){
    const y = yAbs - (cup.y - cup.h/2);
    const w = cupWidthAt(y);
    return { left: cup.x - w/2, right: cup.x + w/2 };
  }

  function insideCup(x, y){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;
    if (y < topY || y > botY) return false;
    const b = cupXBoundsAt(y);
    const margin = cup.wall*0.55;
    return (x > b.left + margin && x < b.right - margin);
  }

  // ---- Render helpers ----
  function rgba(c, a){ return `rgba(${c.r},${c.g},${c.b},${a})`; }

  function drawCup(){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;

    ctx.save();
    ctx.lineWidth = cup.wall;
    ctx.strokeStyle = "rgba(240,248,255,0.85)";
    ctx.fillStyle = "rgba(255,255,255,0.06)";

    ctx.beginPath();
    ctx.moveTo(cup.x - cup.topW/2, topY);
    ctx.lineTo(cup.x - cup.botW/2, botY);
    ctx.quadraticCurveTo(cup.x, botY + 30, cup.x + cup.botW/2, botY);
    ctx.lineTo(cup.x + cup.topW/2, topY);
    ctx.quadraticCurveTo(cup.x, topY - 20, cup.x - cup.topW/2, topY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Rim highlight
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.5)";
    ctx.beginPath();
    ctx.ellipse(cup.x, topY, cup.topW*0.52, cup.rim, 0, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
  }

  function drawLiquid(){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;

    const liquidTop = botY - cup.h * drink.level;

    // Clip to inside cup
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(cup.x - cup.topW/2 + cup.wall, topY + cup.wall);
    ctx.lineTo(cup.x - cup.botW/2 + cup.wall, botY - cup.wall);
    ctx.quadraticCurveTo(cup.x, botY + 20, cup.x + cup.botW/2 - cup.wall, botY - cup.wall);
    ctx.lineTo(cup.x + cup.topW/2 - cup.wall, topY + cup.wall);
    ctx.quadraticCurveTo(cup.x, topY - 10, cup.x - cup.topW/2 + cup.wall, topY + cup.wall);
    ctx.closePath();
    ctx.clip();

    // --- Liquid fill (surface-shaped polygon) ---
    ctx.fillStyle = rgba(drink.color, 0.92);

    const slope = surfaceAngle * 0.9;
    const surfaceMidY = liquidTop;
    const amp = 16 + 26*waveAmp;

    const leftX  = cupXBoundsAt(surfaceMidY).left + cup.wall*0.6;
    const rightX = cupXBoundsAt(surfaceMidY).right - cup.wall*0.6;

    const N = 36;
    ctx.beginPath();
    for (let i=0;i<=N;i++){
      const t = i / N;
      const x = leftX + (rightX - leftX) * t;
      const wave = Math.sin(wavePhase + t*2.2) * amp;
      const y = surfaceMidY + slope * (x - (leftX+rightX)/2) + wave;

      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.lineTo(rightX, botY + 200);
    ctx.lineTo(leftX,  botY + 200);
    ctx.closePath();
    ctx.fill();

    // Surface highlight (same curve)
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 6;
    ctx.beginPath();
    for (let i=0;i<=N;i++){
      const t = i / N;
      const x = leftX + (rightX - leftX) * t;
      const wave = Math.sin(wavePhase + t*2.2) * amp;
      const y = surfaceMidY + slope * (x - (leftX+rightX)/2) + wave;

      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Shiny overlay
    const grad = ctx.createLinearGradient(cup.x - 200, topY, cup.x + 220, botY);
    grad.addColorStop(0, "rgba(255,255,255,0.10)");
    grad.addColorStop(0.5, "rgba(255,255,255,0.00)");
    grad.addColorStop(1, "rgba(255,255,255,0.08)");
    ctx.fillStyle = grad;
    ctx.fillRect(0, topY, W, cup.h);

    ctx.restore();
  }

  function drawToppings(){
    const botY = cup.y + cup.h/2;
    const liquidTop = botY - cup.h * drink.level;

    const sorted = [...toppings].sort((a,b)=> (a.kind==="jelly") - (b.kind==="jelly"));

    for (const p of sorted){
      if (!insideCup(p.x, p.y)) continue;
      if (p.y < liquidTop - 40) continue;

      ctx.beginPath();
      if (p.kind === "boba"){
        ctx.fillStyle = "rgba(35,20,18,0.95)";
        ctx.ellipse(p.x, p.y, p.r, p.r*0.95, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.20)";
        ctx.beginPath();
        ctx.ellipse(p.x - p.r*0.25, p.y - p.r*0.25, p.r*0.35, p.r*0.25, -0.5, 0, Math.PI*2);
        ctx.fill();
      } else {
        ctx.fillStyle = "rgba(255,210,120,0.55)";
        ctx.roundRect(p.x - p.r, p.y - p.r*0.75, p.r*2, p.r*1.5, 6);
        ctx.fill();
      }
    }
  }

  // roundRect polyfill
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+rr, y);
      this.arcTo(x+w, y, x+w, y+h, rr);
      this.arcTo(x+w, y+h, x, y+h, rr);
      this.arcTo(x, y+h, x, y, rr);
      this.arcTo(x, y, x+w, y, rr);
      this.closePath();
      return this;
    }
  }

  // ---- Physics update ----
  function update(dt){
    // Slosh target: use left-right tilt for surface slope.
    const target = tiltLR * 0.55;

    const force = (target - surfaceAngle) * stiffness;
    surfaceVel += force;
    surfaceVel *= damping;
    surfaceAngle += surfaceVel;

    wavePhase += 2.1 * dt;
    waveAmp = clamp(waveAmp * 0.94 + Math.abs(surfaceVel) * 2.2, 0, 1);

    // Sip: forward tilt.
    // Depending on how you hold the phone, this sign may need flipping.
    const sipNow = (tiltFB < -0.55);
    if (sipCooldown > 0) sipCooldown -= dt;

    sipping = sipNow && sipCooldown <= 0 && drink.level > 0.06;

    if (sipping){
      sipStrength = clamp(sipStrength + dt*2.4, 0, 1);
      drink.targetLevel = Math.max(0.05, drink.targetLevel - dt*0.10*(0.35 + 0.65*sipStrength));
      if (audioCtx && Math.random() < 0.08) beepSip(0.6 + 0.4*sipStrength);
    } else {
      sipStrength = Math.max(0, sipStrength - dt*2.0);
    }

    // Smooth approach target level
    drink.level += (drink.targetLevel - drink.level) * (1 - Math.pow(0.0008, dt));

    // Toppings physics
    const gX = tiltLR * 0.50;
    const gY = 0.22;

    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;
    const liquidTop = botY - cup.h * drink.level;

    for (const p of toppings){
      p.vx += gX;
      p.vy += gY;

      // slosh drift
      p.vx += surfaceVel * 0.9;

      p.vx *= 0.96;
      p.vy *= 0.96;

      p.x += p.vx;
      p.y += p.vy;

      // bottom collision
      if (p.y > botY - cup.wall*0.8 - p.r){
        p.y = botY - cup.wall*0.8 - p.r;
        p.vy *= -0.35;
        p.vx *= 0.85;
      }
      // top clamp
      if (p.y < topY + cup.wall*1.4 + p.r){
        p.y = topY + cup.wall*1.4 + p.r;
        p.vy *= -0.20;
      }

      // side walls
      const bounds = cupXBoundsAt(p.y);
      const left = bounds.left + cup.wall*1.0 + p.r;
      const right = bounds.right - cup.wall*1.0 - p.r;

      if (p.x < left){
        p.x = left;
        p.vx *= -0.35;
      }
      if (p.x > right){
        p.x = right;
        p.vx *= -0.35;
      }

      // buoyancy-ish: keep near liquid
      if (p.y < liquidTop + 30){
        p.vy += 0.6;
      }
    }
  }

  function render(){
    ctx.clearRect(0,0,W,H);

    // Background glow
    ctx.save();
    const g = ctx.createRadialGradient(cx, cy-200, 40, cx, cy, 820);
    g.addColorStop(0, "rgba(80,120,255,0.10)");
    g.addColorStop(0.5, "rgba(255,160,120,0.06)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    drawLiquid();
    drawToppings();
    drawCup();

    // Status text
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = "24px -apple-system, system-ui, Segoe UI, Roboto, sans-serif";
    const msg1 = hasMotion ? "기울여 보세요 (슬로싱)" : "Play 후 모션 허용 필요";
    ctx.fillText(msg1, 40, 64);

    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.font = "20px -apple-system, system-ui, Segoe UI, Roboto, sans-serif";
    ctx.fillText(`레벨: ${Math.round(drink.level*100)}%`, 40, 96);

    if (sipping){
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "700 26px -apple-system, system-ui, Segoe UI, Roboto, sans-serif";
      ctx.fillText("마시는 중…", 40, 132);
    }
    ctx.restore();
  }

  // ---- RAF loop ----
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;

    update(dt);
    render();

    requestAnimationFrame(loop);
  }

  // ---- Permission / start ----
  async function requestMotion(){
    // iOS Safari may require requestPermission (either orientation or motion)
    const DOE = window.DeviceOrientationEvent;
    const DME = window.DeviceMotionEvent;

    const fn = (DOE && typeof DOE.requestPermission === "function") ? DOE.requestPermission
           : (DME && typeof DME.requestPermission === "function") ? DME.requestPermission
           : null;

    if (!fn) return true;

    const res = await fn.call(DOE || DME);
    return res === "granted";
  }

  async function start(){
    // Audio context must be created on user gesture
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      try { await audioCtx.resume(); } catch(e){}
    }

    // Request motion permission (if needed)
    try{
      const ok = await requestMotion();
      if (!ok){
        alert("모션 권한이 거부되어 기울기 입력이 안 됩니다. (설정에서 허용 필요)");
      }
    }catch(err){
      // still attempt to listen
    }

    // Attach listener (gravity-based)
    window.addEventListener("devicemotion", handleMotion, true);

    // Reset state
    drink.level = 0.78;
    drink.targetLevel = 0.78;
    surfaceAngle = 0;
    surfaceVel = 0;
    waveAmp = 0;
    sipCooldown = 0.2;
    resetToppings();
    hasMotion = false;

    // Start animation once
    if (!start._started){
      start._started = true;
      requestAnimationFrame(loop);
    }

    // brief beep to confirm audio
    beepSip(0.2);
  }

  document.getElementById("playBtn").addEventListener("click", async () => {
    await start();
  });

})();
</script>
</body>
</html>
