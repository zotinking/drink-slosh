<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Drink Slosh (iOS Test)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0f14; color:#e8eef6; font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif; }
    .wrap { height:100%; display:flex; flex-direction:column; }
    .topbar { padding:14px 14px 10px; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .title { font-size:16px; opacity:0.95; }
    .hint { font-size:12px; opacity:0.7; line-height:1.25; }
    .btn {
      appearance:none; border:0; border-radius:14px; padding:12px 16px;
      background:#2b6cff; color:white; font-weight:700; font-size:16px;
      box-shadow: 0 8px 24px rgba(43,108,255,0.35);
      cursor:pointer;
    }
    .btn:active { transform: translateY(1px); }
    .stage { flex:1; display:flex; align-items:center; justify-content:center; padding: 10px 12px 18px; }
    canvas { width: 100%; max-width: 520px; height: auto; border-radius: 22px; background: radial-gradient(1200px 700px at 50% 20%, rgba(255,255,255,0.05), rgba(255,255,255,0.0) 45%); }
    .footer { padding: 0 14px 14px; font-size: 12px; opacity:0.7; }
    .pill { display:inline-block; padding:4px 8px; border-radius: 999px; background: rgba(255,255,255,0.08); margin-right:6px; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div>
      <div class="title">Drink Slosh (iOS Test)</div>
      <div class="hint">Play → 모션 권한. 폰을 화면 수직축으로 시계방향 회전하면 표면은 반시계방향으로 동일각 회전(지면 수평 유지).</div>
    </div>
    <button id="playBtn" class="btn">Play</button>
  </div>

  <div class="stage">
    <canvas id="c" width="900" height="1200"></canvas>
  </div>

  <div class="footer">
    <span class="pill">중력(기울기): 토핑 이동</span>
    <span class="pill">yaw(각도): 표면 각도 = -yaw</span>
    <span class="pill">Play는 권한/오디오 트리거</span>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;

  const cup = { x: cx, y: cy + 40, topW: 420, botW: 300, h: 620, rim: 26, wall: 18 };

  const drink = {
    color: { r: 207, g: 126, b: 111 },
    level: 0.78,
    targetLevel: 0.78
  };

  const toppings = [];
  const TOPPING_COUNT = 38;

  // ---------- utils ----------
  const TAU = Math.PI * 2;
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rgba(c,a){ return `rgba(${c.r},${c.g},${c.b},${a})`; }
  function wrapRad(x){
    // wrap to [-pi, pi]
    x = (x + Math.PI) % (Math.PI*2);
    if (x < 0) x += Math.PI*2;
    return x - Math.PI;
  }
  function degToRad(d){ return d * Math.PI / 180; }

  function resetToppings(){
    toppings.length = 0;
    for (let i=0;i<TOPPING_COUNT;i++){
      toppings.push({
        x: cup.x + (Math.random()-0.5) * (cup.topW*0.35),
        y: cup.y + (Math.random()*0.45 + 0.1) * cup.h,
        r: 10 + Math.random()*6,
        vx: (Math.random()-0.5)*2,
        vy: (Math.random()-0.5)*1.5,
        kind: Math.random() < 0.75 ? "boba" : "jelly"
      });
    }
  }
  resetToppings();

  // ---------- sensors ----------
  // Gravity tilt (for toppings)
  let tiltLR = 0; // -1..1
  let tiltFB = 0; // -1..1
  let hasMotion = false;

  // Yaw angle (for surface): use DeviceOrientation alpha with baseline offset
  let yaw0 = null;          // baseline alpha(rad) at Play
  let yawRad = 0;           // current yaw relative to yaw0 (rad)
  let surfaceTheta = 0;     // actual used surface direction angle (rad)
  let surfaceThetaVel = 0;  // smoothing
  const thetaStiff = 18.0;  // spring stiffness
  const thetaDamp  = 0.82;  // damping

  // wave
  let wavePhase = 0;
  let waveAmp = 0;

  function handleMotion(e){
    const g = e.accelerationIncludingGravity;
    if (!g) return;

    const gx = (typeof g.x === "number") ? g.x : 0;
    const gy = (typeof g.y === "number") ? g.y : 0;

    tiltLR = clamp((-gx)/9.81, -1, 1);
    tiltFB = clamp((gy)/9.81, -1, 1);
    hasMotion = true;
  }

  function handleOrientation(e){
    // alpha: 0..360 degrees (yaw-ish)
    if (typeof e.alpha !== "number") return;
    const a = degToRad(e.alpha);

    if (yaw0 === null) yaw0 = a; // capture baseline after Play
    yawRad = wrapRad(a - yaw0);
  }

  // ---------- audio (optional beep) ----------
  let audioCtx = null;
  function beepSip(intensity){
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filt = audioCtx.createBiquadFilter();
    filt.type = "lowpass";
    filt.frequency.setValueAtTime(900 + 700*intensity, t0);

    osc.type = "triangle";
    osc.frequency.setValueAtTime(260 + 120*intensity, t0);

    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(0.08 + 0.06*intensity, t0 + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.18);

    osc.connect(filt).connect(gain).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + 0.2);
  }

  // ---------- cup geometry helpers ----------
  function cupWidthAt(y){
    const t = clamp(y / cup.h, 0, 1);
    return cup.topW + (cup.botW - cup.topW) * t;
  }
  function cupXBoundsAt(yAbs){
    const y = yAbs - (cup.y - cup.h/2);
    const w = cupWidthAt(y);
    return { left: cup.x - w/2, right: cup.x + w/2 };
  }
  function insideCup(x, y){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;
    if (y < topY || y > botY) return false;
    const b = cupXBoundsAt(y);
    const margin = cup.wall*0.55;
    return (x > b.left + margin && x < b.right - margin);
  }

  // ---------- drawing ----------
  function drawCup(){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;

    ctx.save();
    ctx.lineWidth = cup.wall;
    ctx.strokeStyle = "rgba(240,248,255,0.85)";
    ctx.fillStyle = "rgba(255,255,255,0.06)";

    ctx.beginPath();
    ctx.moveTo(cup.x - cup.topW/2, topY);
    ctx.lineTo(cup.x - cup.botW/2, botY);
    ctx.quadraticCurveTo(cup.x, botY + 30, cup.x + cup.botW/2, botY);
    ctx.lineTo(cup.x + cup.topW/2, topY);
    ctx.quadraticCurveTo(cup.x, topY - 20, cup.x - cup.topW/2, topY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.5)";
    ctx.beginPath();
    ctx.ellipse(cup.x, topY, cup.topW*0.52, cup.rim, 0, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
  }

  // 핵심: 각도 기반 표면(0~90°에서도 안정)
  function drawLiquid(){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;
    const liquidTop = botY - cup.h * drink.level;

    ctx.save();

    // clip to inside cup
    ctx.beginPath();
    ctx.moveTo(cup.x - cup.topW/2 + cup.wall, topY + cup.wall);
    ctx.lineTo(cup.x - cup.botW/2 + cup.wall, botY - cup.wall);
    ctx.quadraticCurveTo(cup.x, botY + 20, cup.x + cup.botW/2 - cup.wall, botY - cup.wall);
    ctx.lineTo(cup.x + cup.topW/2 - cup.wall, topY + cup.wall);
    ctx.quadraticCurveTo(cup.x, topY - 10, cup.x - cup.topW/2 + cup.wall, topY + cup.wall);
    ctx.closePath();
    ctx.clip();

    ctx.fillStyle = rgba(drink.color, 0.92);

    // 표면 "방향" 각도 theta:
    // 요구사항: phone CW +90 => surface CCW +90 => surfaceTheta = -yaw
    const theta = surfaceTheta;

    // direction vector along surface line
    const dx = Math.cos(theta);
    const dy = Math.sin(theta);
    // normal vector (perpendicular)
    const nx = -dy;
    const ny = dx;

    const amp = 12 + 22 * waveAmp;
    const midX = cup.x;
    const midY = liquidTop;

    // choose length enough to span the cup; clip will cut it
    const span = Math.max(cup.topW, cup.h) * 0.9;

    const N = 44;
    ctx.beginPath();
    for (let i=0;i<=N;i++){
      const t = i / N;                 // 0..1
      const s = (t - 0.5) * 2 * span;  // -span..+span

      // base point on the line
      let x = midX + dx * s;
      let y = midY + dy * s;

      // wave offset along normal direction
      const w = Math.sin(wavePhase + t*2.6) * amp;
      x += nx * w;
      y += ny * w;

      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }

    // close far down so it fills "below surface" regardless of angle
    ctx.lineTo(W + 1000, botY + 3000);
    ctx.lineTo(-1000, botY + 3000);
    ctx.closePath();
    ctx.fill();

    // highlight along same curve
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 6;
    ctx.beginPath();
    for (let i=0;i<=N;i++){
      const t = i / N;
      const s = (t - 0.5) * 2 * span;

      let x = midX + dx * s;
      let y = midY + dy * s;

      const w = Math.sin(wavePhase + t*2.6) * amp;
      x += nx * w;
      y += ny * w;

      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // shine overlay
    const grad = ctx.createLinearGradient(cup.x - 200, topY, cup.x + 220, botY);
    grad.addColorStop(0, "rgba(255,255,255,0.10)");
    grad.addColorStop(0.5, "rgba(255,255,255,0.00)");
    grad.addColorStop(1, "rgba(255,255,255,0.08)");
    ctx.fillStyle = grad;
    ctx.fillRect(0, topY, W, cup.h);

    ctx.restore();
  }

  // roundRect polyfill
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+rr, y);
      this.arcTo(x+w, y, x+w, y+h, rr);
      this.arcTo(x+w, y+h, x, y+h, rr);
      this.arcTo(x, y+h, x, y, rr);
      this.arcTo(x, y, x+w, y, rr);
      this.closePath();
      return this;
    }
  }

  function drawToppings(){
    const botY = cup.y + cup.h/2;
    const liquidTop = botY - cup.h * drink.level;
    const sorted = [...toppings].sort((a,b)=> (a.kind==="jelly") - (b.kind==="jelly"));

    for (const p of sorted){
      if (!insideCup(p.x, p.y)) continue;
      if (p.y < liquidTop - 40) continue;

      if (p.kind === "boba"){
        ctx.fillStyle = "rgba(35,20,18,0.95)";
        ctx.beginPath();
        ctx.ellipse(p.x, p.y, p.r, p.r*0.95, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.20)";
        ctx.beginPath();
        ctx.ellipse(p.x - p.r*0.25, p.y - p.r*0.25, p.r*0.35, p.r*0.25, -0.5, 0, Math.PI*2);
        ctx.fill();
      } else {
        ctx.fillStyle = "rgba(255,210,120,0.55)";
        ctx.beginPath();
        ctx.roundRect(p.x - p.r, p.y - p.r*0.75, p.r*2, p.r*1.5, 6);
        ctx.fill();
      }
    }
  }

  // ---------- update ----------
  function update(dt){
    // 1) surface angle target: -yaw (요구사항 그대로)
    const targetTheta = +yawRad; // CW phone -> CCW surface
    const err = wrapRad(targetTheta - surfaceTheta);
    // spring smoothing
    surfaceThetaVel += err * thetaStiff * dt;
    surfaceThetaVel *= Math.pow(thetaDamp, dt*60);
    surfaceTheta += surfaceThetaVel * dt;
    surfaceTheta = wrapRad(surfaceTheta);

    // wave: 조금만
    wavePhase += 2.0 * dt;
    waveAmp = clamp(waveAmp * 0.92 + Math.min(1, Math.abs(surfaceThetaVel) * 0.8), 0, 1);

    // 2) level (테스트용: 감소 없음)
    drink.level += (drink.targetLevel - drink.level) * (1 - Math.pow(0.0008, dt));

    // 3) toppings: gravity tilt로만 (표면 회전과 독립)
    const gX = tiltLR * 0.55;
    const gY = 0.22;

    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;
    const liquidTop = botY - cup.h * drink.level;

    for (const p of toppings){
      p.vx += gX;
      p.vy += gY;

      p.vx *= 0.96;
      p.vy *= 0.96;

      p.x += p.vx;
      p.y += p.vy;

      if (p.y > botY - cup.wall*0.8 - p.r){
        p.y = botY - cup.wall*0.8 - p.r;
        p.vy *= -0.35;
        p.vx *= 0.85;
      }
      if (p.y < topY + cup.wall*1.4 + p.r){
        p.y = topY + cup.wall*1.4 + p.r;
        p.vy *= -0.20;
      }

      const bounds = cupXBoundsAt(p.y);
      const left = bounds.left + cup.wall*1.0 + p.r;
      const right = bounds.right - cup.wall*1.0 - p.r;

      if (p.x < left){ p.x = left; p.vx *= -0.35; }
      if (p.x > right){ p.x = right; p.vx *= -0.35; }

      if (p.y < liquidTop + 30){
        p.vy += 0.6;
      }
    }
  }

  function render(){
    ctx.clearRect(0,0,W,H);

    // background glow
    ctx.save();
    const bg = ctx.createRadialGradient(cx, cy-200, 40, cx, cy, 820);
    bg.addColorStop(0, "rgba(80,120,255,0.10)");
    bg.addColorStop(0.5, "rgba(255,160,120,0.06)");
    bg.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    drawLiquid();
    drawToppings();
    drawCup();

    // status
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = "24px -apple-system, system-ui, Segoe UI, Roboto, sans-serif";
    ctx.fillText(hasMotion ? "기울여 보세요 (토핑 이동)" : "Play 후 모션 허용 필요", 40, 64);

    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.font = "20px -apple-system, system-ui, Segoe UI, Roboto, sans-serif";
    ctx.fillText(`레벨: ${Math.round(drink.level*100)}% | yaw: ${Math.round(yawRad*180/Math.PI)}° | surface: ${Math.round(surfaceTheta*180/Math.PI)}°`, 40, 96);
    ctx.restore();
  }

  // ---------- raf ----------
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // ---------- permission / start ----------
  async function requestMotion(){
    const DOE = window.DeviceOrientationEvent;
    const DME = window.DeviceMotionEvent;

    const fn = (DOE && typeof DOE.requestPermission === "function") ? DOE.requestPermission
           : (DME && typeof DME.requestPermission === "function") ? DME.requestPermission
           : null;

    if (!fn) return true;
    const res = await fn.call(DOE || DME);
    return res === "granted";
  }

  async function start(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      try { await audioCtx.resume(); } catch(e){}
    }

    try{
      const ok = await requestMotion();
      if (!ok) alert("모션 권한이 거부되어 일부 동작이 제한됩니다.");
    } catch(e){}

    // listen both: motion(for gravity) + orientation(for yaw angle)
    window.addEventListener("devicemotion", handleMotion, true);
    window.addEventListener("deviceorientation", handleOrientation, true);

    // reset yaw baseline at start
    yaw0 = null;
    yawRad = 0;
    surfaceTheta = 0;
    surfaceThetaVel = 0;

    drink.level = 0.78;
    drink.targetLevel = 0.78;
    waveAmp = 0;
    resetToppings();
    hasMotion = false;

    if (!start._started){
      start._started = true;
      requestAnimationFrame(loop);
    }

    beepSip(0.2);
  }

  document.getElementById("playBtn").addEventListener("click", start);
})();
</script>
</body>
</html>

