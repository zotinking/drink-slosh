<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Drink Slosh (iOS Test)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0f14; color:#e8eef6; font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif; }
    .wrap { height:100%; display:flex; flex-direction:column; }
    .topbar { padding:14px 14px 10px; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .title { font-size:16px; opacity:0.95; }
    .hint { font-size:12px; opacity:0.7; line-height:1.25; }
    .btn {
      appearance:none; border:0; border-radius:14px; padding:12px 16px;
      background:#2b6cff; color:white; font-weight:700; font-size:16px;
      box-shadow: 0 8px 24px rgba(43,108,255,0.35);
      cursor:pointer;
    }
    .btn:active { transform: translateY(1px); }
    .stage { flex:1; display:flex; align-items:center; justify-content:center; padding: 10px 12px 18px; }
    canvas { width: 100%; max-width: 520px; height: auto; border-radius: 22px; background: radial-gradient(1200px 700px at 50% 20%, rgba(255,255,255,0.05), rgba(255,255,255,0.0) 45%); }
    .footer { padding: 0 14px 14px; font-size: 12px; opacity:0.7; }
    .pill { display:inline-block; padding:4px 8px; border-radius: 999px; background: rgba(255,255,255,0.08); margin-right:6px; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div>
      <div class="title">Drink Slosh (iOS Test)</div>
      <div class="hint">
        Play → 모션 권한. 기본(책상 위)에서는 마시지 않음. 얼굴 앞(대략 수직)에서 화면 수직축(yaw) 회전 시 마시기.
      </div>
    </div>
    <button id="playBtn" class="btn">Play</button>
  </div>

  <div class="stage">
    <canvas id="c" width="900" height="1200"></canvas>
  </div>

  <div class="footer">
    <span class="pill">기울이기: 슬로싱</span>
    <span class="pill">얼굴 앞(수직) + yaw 회전: 마시기</span>
    <span class="pill">Play는 권한/오디오 트리거</span>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;

  const cup = { x: cx, y: cy + 40, topW: 420, botW: 300, h: 620, rim: 26, wall: 18 };

  const drink = {
    color: { r: 207, g: 126, b: 111 },
    level: 0.78,
    targetLevel: 0.78
  };

  const toppings = [];
  const TOPPING_COUNT = 38;

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function resetToppings() {
    toppings.length = 0;
    for (let i=0;i<TOPPING_COUNT;i++){
      toppings.push({
        x: cup.x + (Math.random()-0.5) * (cup.topW*0.35),
        y: cup.y + (Math.random()*0.45 + 0.1) * cup.h,
        r: 10 + Math.random()*6,
        vx: (Math.random()-0.5)*2,
        vy: (Math.random()-0.5)*1.5,
        kind: Math.random() < 0.75 ? "boba" : "jelly"
      });
    }
  }
  resetToppings();

  // ---------------- Motion input ----------------
  // Slosh uses gravity tilt (LR mainly). Sip uses "upright gate + yaw rotation rate".
  let tiltLR = 0;      // -1..1
  let tiltFB = 0;      // -1..1 (슬로싱/보조용)
  let gzN = 1;         // gravity z normalized (-1..1). |gzN|~1 => face-up/down, ~0 => vertical-ish
  let yawRateAlpha = 0; // deg/s (from rotationRate.alpha), smoothed
  let hasMotion = false;

  function handleMotion(e){
    const g = e.accelerationIncludingGravity;
    if (g) {
      const gx = (typeof g.x === "number") ? g.x : 0;
      const gy = (typeof g.y === "number") ? g.y : 0;
      const gz = (typeof g.z === "number") ? g.z : 0;

      tiltLR = clamp((-gx) / 9.81, -1, 1);
      tiltFB = clamp((gy) / 9.81, -1, 1);
      gzN    = clamp((gz) / 9.81, -1, 1);

      hasMotion = true;
    }

    // rotationRate for yaw-trigger sipping
    // iOS: rotationRate.alpha is "rate around z axis" in deg/s (commonly).
    // Some devices may provide null; then yawRateAlpha stays ~0 (no sip).
    const rr = e.rotationRate;
    const rawAlpha = (rr && typeof rr.alpha === "number") ? rr.alpha : 0;

    // Smooth to avoid jitter
    yawRateAlpha = yawRateAlpha * 0.85 + rawAlpha * 0.15;
  }

  // ---------------- Slosh model ----------------
  let surfaceAngle = 0;
  let surfaceVel   = 0;
  const stiffness = 0.09;
  const damping   = 0.88;

  let wavePhase = 0;
  let waveAmp = 0;

  // ---------------- Sip effect ----------------
  let sipping = false;
  let sipStrength = 0;
  let sipCooldown = 0;

  // ---------------- Audio ----------------
  let audioCtx = null;

  function beepSip(intensity){
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filt = audioCtx.createBiquadFilter();
    filt.type = "lowpass";
    filt.frequency.setValueAtTime(900 + 700*intensity, t0);

    osc.type = "triangle";
    osc.frequency.setValueAtTime(260 + 120*intensity, t0);

    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(0.10 + 0.08*intensity, t0 + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);

    osc.connect(filt).connect(gain).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + 0.25);
  }

  // ---------------- Cup geometry helpers ----------------
  function cupWidthAt(y){
    const t = clamp(y / cup.h, 0, 1);
    return cup.topW + (cup.botW - cup.topW) * t;
  }

  function cupXBoundsAt(yAbs){
    const y = yAbs - (cup.y - cup.h/2);
    const w = cupWidthAt(y);
    return { left: cup.x - w/2, right: cup.x + w/2 };
  }

  function insideCup(x, y){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;
    if (y < topY || y > botY) return false;
    const b = cupXBoundsAt(y);
    const margin = cup.wall*0.55;
    return (x > b.left + margin && x < b.right - margin);
  }

  function rgba(c, a){ return `rgba(${c.r},${c.g},${c.b},${a})`; }

  // ---------------- Drawing ----------------
  function drawCup(){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;

    ctx.save();
    ctx.lineWidth = cup.wall;
    ctx.strokeStyle = "rgba(240,248,255,0.85)";
    ctx.fillStyle = "rgba(255,255,255,0.06)";

    ctx.beginPath();
    ctx.moveTo(cup.x - cup.topW/2, topY);
    ctx.lineTo(cup.x - cup.botW/2, botY);
    ctx.quadraticCurveTo(cup.x, botY + 30, cup.x + cup.botW/2, botY);
    ctx.lineTo(cup.x + cup.topW/2, topY);
    ctx.quadraticCurveTo(cup.x, topY - 20, cup.x - cup.topW/2, topY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.5)";
    ctx.beginPath();
    ctx.ellipse(cup.x, topY, cup.topW*0.52, cup.rim, 0, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
  }

  function drawLiquid(){
    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;
    const liquidTop = botY - cup.h * drink.level;

    ctx.save();
    // Clip to inside cup
    ctx.beginPath();
    ctx.moveTo(cup.x - cup.topW/2 + cup.wall, topY + cup.wall);
    ctx.lineTo(cup.x - cup.botW/2 + cup.wall, botY - cup.wall);
    ctx.quadraticCurveTo(cup.x, botY + 20, cup.x + cup.botW/2 - cup.wall, botY - cup.wall);
    ctx.lineTo(cup.x + cup.topW/2 - cup.wall, topY + cup.wall);
    ctx.quadraticCurveTo(cup.x, topY - 10, cup.x - cup.topW/2 + cup.wall, topY + cup.wall);
    ctx.closePath();
    ctx.clip();

    // Surface-shaped fill
    ctx.fillStyle = rgba(drink.color, 0.92);

    const slope = surfaceAngle * 0.9;
    const surfaceMidY = liquidTop;
    const amp = 16 + 26*waveAmp;

    const leftX  = cupXBoundsAt(surfaceMidY).left + cup.wall*0.6;
    const rightX = cupXBoundsAt(surfaceMidY).right - cup.wall*0.6;

    const N = 36;
    ctx.beginPath();
    for (let i=0;i<=N;i++){
      const t = i / N;
      const x = leftX + (rightX - leftX) * t;
      const wave = Math.sin(wavePhase + t*2.2) * amp;
      const y = surfaceMidY + slope * (x - (leftX+rightX)/2) + wave;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.lineTo(rightX, botY + 200);
    ctx.lineTo(leftX,  botY + 200);
    ctx.closePath();
    ctx.fill();

    // Surface highlight (same curve)
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 6;
    ctx.beginPath();
    for (let i=0;i<=N;i++){
      const t = i / N;
      const x = leftX + (rightX - leftX) * t;
      const wave = Math.sin(wavePhase + t*2.2) * amp;
      const y = surfaceMidY + slope * (x - (leftX+rightX)/2) + wave;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Shine overlay
    const grad = ctx.createLinearGradient(cup.x - 200, topY, cup.x + 220, botY);
    grad.addColorStop(0, "rgba(255,255,255,0.10)");
    grad.addColorStop(0.5, "rgba(255,255,255,0.00)");
    grad.addColorStop(1, "rgba(255,255,255,0.08)");
    ctx.fillStyle = grad;
    ctx.fillRect(0, topY, W, cup.h);

    ctx.restore();
  }

  // roundRect polyfill
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+rr, y);
      this.arcTo(x+w, y, x+w, y+h, rr);
      this.arcTo(x+w, y+h, x, y+h, rr);
      this.arcTo(x, y+h, x, y, rr);
      this.arcTo(x, y, x+w, y, rr);
      this.closePath();
      return this;
    }
  }

  function drawToppings(){
    const botY = cup.y + cup.h/2;
    const liquidTop = botY - cup.h * drink.level;

    const sorted = [...toppings].sort((a,b)=> (a.kind==="jelly") - (b.kind==="jelly"));

    for (const p of sorted){
      if (!insideCup(p.x, p.y)) continue;
      if (p.y < liquidTop - 40) continue;

      if (p.kind === "boba"){
        ctx.fillStyle = "rgba(35,20,18,0.95)";
        ctx.beginPath();
        ctx.ellipse(p.x, p.y, p.r, p.r*0.95, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.20)";
        ctx.beginPath();
        ctx.ellipse(p.x - p.r*0.25, p.y - p.r*0.25, p.r*0.35, p.r*0.25, -0.5, 0, Math.PI*2);
        ctx.fill();
      } else {
        ctx.fillStyle = "rgba(255,210,120,0.55)";
        ctx.beginPath();
        ctx.roundRect(p.x - p.r, p.y - p.r*0.75, p.r*2, p.r*1.5, 6);
        ctx.fill();
      }
    }
  }

  // ---------------- Update loop ----------------
  function update(dt){
    // Slosh (gravity-based)
    const target = tiltLR * 0.55;
    const force = (target - surfaceAngle) * stiffness;
    surfaceVel += force;
    surfaceVel *= damping;
    surfaceAngle += surfaceVel;

    wavePhase += 2.1 * dt;
    waveAmp = clamp(waveAmp * 0.94 + Math.abs(surfaceVel) * 2.2, 0, 1);

    // ---- Sip trigger (NEW):
    // - Base state: phone face-up on desk => |gzN| ~ 1  => NOT sipping
    // - When lifted to face (roughly vertical) => |gzN| near 0 => "upright gate" open
    // - Sip when yaw rotation happens while gate open (use rotationRate.alpha)
    const uprightGate = (Math.abs(gzN) < 0.35); // ~ vertical-ish. tweak 0.25~0.45 if needed.

    // yawRateAlpha: deg/s. Use magnitude; allow both CW/CCW.
    const yawRate = Math.abs(yawRateAlpha);

    // threshold: start sipping only when yaw rotation is noticeable.
    // tweak 25~60 based on feel.
    const sipNow = uprightGate && (yawRate > 35) && (drink.level > 0.06);

    if (sipCooldown > 0) sipCooldown -= dt;

    const allowSip = sipNow && sipCooldown <= 0;

    if (allowSip){
      sipping = true;
      // Strength scales with yaw rate (clamped)
      const rateNorm = clamp((yawRate - 35) / 120, 0, 1);
      sipStrength = clamp(sipStrength + dt * (2.0 + 3.0*rateNorm), 0, 1);

      // Drain speed depends on sipStrength
      drink.targetLevel = Math.max(0.05, drink.targetLevel - dt * 0.14 * (0.25 + 0.75*sipStrength));

      if (audioCtx && Math.random() < 0.08) beepSip(0.6 + 0.4*sipStrength);
    } else {
      sipping = false;
      sipStrength = Math.max(0, sipStrength - dt*2.2);
    }

    // Smooth approach target level
    drink.level += (drink.targetLevel - drink.level) * (1 - Math.pow(0.0008, dt));

    // Toppings physics
    const gX = tiltLR * 0.50;
    const gY = 0.22;

    const topY = cup.y - cup.h/2;
    const botY = cup.y + cup.h/2;
    const liquidTop = botY - cup.h * drink.level;

    for (const p of toppings){
      p.vx += gX;
      p.vy += gY;

      // slosh drift
      p.vx += surfaceVel * 0.9;

      p.vx *= 0.96;
      p.vy *= 0.96;

      p.x += p.vx;
      p.y += p.vy;

      // bottom collision
      if (p.y > botY - cup.wall*0.8 - p.r){
        p.y = botY - cup.wall*0.8 - p.r;
        p.vy *= -0.35;
        p.vx *= 0.85;
      }
      // top clamp
      if (p.y < topY + cup.wall*1.4 + p.r){
        p.y = topY + cup.wall*1.4 + p.r;
        p.vy *= -0.20;
      }

      // side walls
      const bounds = cupXBoundsAt(p.y);
      const left = bounds.left + cup.wall*1.0 + p.r;
      const right = bounds.right - cup.wall*1.0 - p.r;

      if (p.x < left){
        p.x = left;
        p.vx *= -0.35;
      }
      if (p.x > right){
        p.x = right;
        p.vx *= -0.35;
      }

      // keep near liquid
      if (p.y < liquidTop + 30){
        p.vy += 0.6;
      }
    }
  }

  function render(){
    ctx.clearRect(0,0,W,H);

    // Background glow
    ctx.save();
    const bg = ctx.createRadialGradient(cx, cy-200, 40, cx, cy, 820);
    bg.addColorStop(0, "rgba(80,120,255,0.10)");
    bg.addColorStop(0.5, "rgba(255,160,120,0.06)");
    bg.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    drawLiquid();
    drawToppings();
    drawCup();

    // Status text
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = "24px -apple-system, system-ui, Segoe UI, Roboto, sans-serif";
    const msg1 = hasMotion ? "기울여 보세요 (슬로싱)" : "Play 후 모션 허용 필요";
    ctx.fillText(msg1, 40, 64);

    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.font = "20px -apple-system, system-ui, Segoe UI, Roboto, sans-serif";
    ctx.fillText(`레벨: ${Math.round(drink.level*100)}%`, 40, 96);

    // Debug-ish (optional)
    const uprightGate = (Math.abs(gzN) < 0.35);
    ctx.fillText(`수직게이트: ${uprightGate ? "ON" : "OFF"} | yawRate: ${Math.round(Math.abs(yawRateAlpha))}°/s`, 40, 126);

    if (sipping){
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "700 26px -apple-system, system-ui, Segoe UI, Roboto, sans-serif";
      ctx.fillText("마시는 중…", 40, 162);
    }
    ctx.restore();
  }

  // ---------------- RAF loop ----------------
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // ---------------- Permission / start ----------------
  async function requestMotion(){
    const DOE = window.DeviceOrientationEvent;
    const DME = window.DeviceMotionEvent;

    const fn = (DOE && typeof DOE.requestPermission === "function") ? DOE.requestPermission
           : (DME && typeof DME.requestPermission === "function") ? DME.requestPermission
           : null;

    if (!fn) return true;

    const res = await fn.call(DOE || DME);
    return res === "granted";
  }

  async function start(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      try { await audioCtx.resume(); } catch(e){}
    }

    try{
      const ok = await requestMotion();
      if (!ok){
        alert("모션 권한이 거부되어 동작이 제한됩니다. (설정에서 허용 필요)");
      }
    }catch(err){
      // still attempt
    }

    window.addEventListener("devicemotion", handleMotion, true);

    // Reset state
    drink.level = 0.78;
    drink.targetLevel = 0.78;
    surfaceAngle = 0;
    surfaceVel = 0;
    waveAmp = 0;
    sipCooldown = 0.25;
    yawRateAlpha = 0;
    gzN = 1;
    hasMotion = false;
    resetToppings();

    if (!start._started){
      start._started = true;
      requestAnimationFrame(loop);
    }

    beepSip(0.2);
  }

  document.getElementById("playBtn").addEventListener("click", async () => {
    await start();
  });
})();
</script>
</body>
</html>
